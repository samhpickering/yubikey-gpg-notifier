#!/usr/bin/env python

import asyncio
import datetime
import logging
import sys
import tomllib

from pathlib import Path
from typing import Coroutine, Any

logging.basicConfig(filename="/tmp/yubikey-gpg-notifier.log", level=logging.DEBUG)
logging.debug(("-" * 27) + str(datetime.datetime.now()) + ("-" * 27))

config = {}
try:
    config_path = Path.home() / Path(".config/yubikey-gpg-notifier.toml")
    logging.info("Attempting to load config from %s", config_path)

    with open(config_path, "rb") as config_file:
        config = tomllib.load(config_file)
    logging.info("Config successfully loaded")
except FileNotFoundError:
    logging.info("Config file not found, using defaults")
except tomllib.TOMLDecodeError as exc:
    logging.error("Error decoding config file, using defaults")
    logging.error(exc)

SCDAEMON = config.get("scdaemon", "scdaemon")
NOTIFY_COMMAND = config.get("notify_command", r"terminal-notifier -group yubikey-gpg-notifier -sender com.yubico.yubioath -title YubiKey -message 'Touch to release %operation operation'")
CANCEL_COMMAND = config.get("cancel_command", "terminal-notifier -remove yubikey-gpg-notifier -sender com.yubico.yubioath")
WAIT_TIME = config.get("wait_time", 0.3)

async def connect_stdin_stdout() -> tuple[asyncio.StreamReader, asyncio.StreamWriter]:
    loop = asyncio.get_event_loop()

    reader = asyncio.StreamReader()
    protocol = asyncio.StreamReaderProtocol(reader)
    await loop.connect_read_pipe(lambda: protocol, sys.stdin)

    w_transport, w_protocol = await loop.connect_write_pipe(asyncio.streams.FlowControlMixin, sys.stdout)
    writer = asyncio.StreamWriter(w_transport, w_protocol, reader, loop)

    return reader, writer

async def tee_stream(
    reader: asyncio.StreamReader,
    writer: asyncio.StreamWriter,
    queue: asyncio.Queue,
    key: int
) -> Coroutine[Any, Any, Any]:
    while data := await reader.readline():
        writer.write(data)
        await queue.put((key, data))
    await queue.put((key, None))

async def notify(operation: str):
    command = str(NOTIFY_COMMAND).replace(r"%operation", operation)
    logging.debug("Sending notification with %s", command)
    await asyncio.create_subprocess_shell(
        command,
        stdin=asyncio.subprocess.DEVNULL,
        stdout=asyncio.subprocess.DEVNULL,
        stderr=asyncio.subprocess.DEVNULL
    )

async def cancel_notification():
    logging.debug("Cancelling notification with %s", CANCEL_COMMAND)
    await asyncio.create_subprocess_shell(
        CANCEL_COMMAND,
        stdin=asyncio.subprocess.DEVNULL,
        stdout=asyncio.subprocess.DEVNULL,
        stderr=asyncio.subprocess.DEVNULL
    )

def get_touch_command(data: bytes) -> str | None:
    if data[:6] == b"PKAUTH":
        return "authentication"
    if data[:6] == b"PKSIGN":
        return "signing"
    if data[:9] == b"PKDECRYPT":
        return "decryption"


async def main():
    passed_args = sys.argv[1:]

    scdaemon = await asyncio.create_subprocess_exec(
        SCDAEMON, *passed_args,
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    STDIN = 1
    STDOUT = 2

    queue = asyncio.Queue()
    reader, writer = await connect_stdin_stdout()
    stdin_task = asyncio.create_task(tee_stream(reader, scdaemon.stdin, queue, STDIN))
    stdout_task = asyncio.create_task(tee_stream(scdaemon.stdout, writer, queue, STDOUT))

    operation = None
    waiting = False
    notified = False
    while True:
        key, data = await queue.get()

        if data == None:
            logging.debug("Empty input, exiting (%s)", key)
            break

        if key == STDIN:
            logging.debug("STDIN:  %s", data)

            waiting = False

            if get_touch_command(data):
                operation = get_touch_command(data)
                logging.debug("Detected %s command", operation)

            if data[:7] == b"RESTART":
                operation = None
                waiting = False

        if key == STDOUT:
            logging.debug("STDOUT: %s", data)

            if data[:14] == b"S PINCACHE_PUT" and queue.empty():
                await asyncio.sleep(WAIT_TIME)

                if queue.empty():
                    waiting = True
                    await notify(operation)
                    notified = True
            else:
                waiting = False

        if notified and not waiting:
            await cancel_notification()
            notified = False

if __name__ == "__main__":
    asyncio.run(main())
